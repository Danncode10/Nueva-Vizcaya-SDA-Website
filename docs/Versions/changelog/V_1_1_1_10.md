#### Header
- **Title**: Version 1.1.1.10 - Backend & Frontend JWT Handling
- **Date**: 2026-01-21

#### What We Did Section
- **Environment Setup**: Configured local backend and frontend development environments to handle JWTs.
- **Documentation Updates**: Marked the 'Implement JWT handling' task as completed in Version 1.md Roadmap.
- **Files Created/Modified**:
  - **Backend**:
    - `backend/backend/app/core/config.py`: Added `cognito_jwks_url` property for JWT validation.
    - `backend/backend/app/core/security.py`: Created a new file to house JWT validation logic and FastAPI `Depends`.
    - `backend/backend/app/main.py`: Imported new security dependency and added an example protected endpoint `/users/me`.
  - **Frontend**:
    - `ui/src/services/auth.ts`: Created new file for auth service, including token storage, refresh, and Axios interceptors.
    - `ui/src/main.tsx`: Initialized Axios interceptors for automatic JWT handling.
    - `ui/src/pages/Login.tsx`: Updated to use `authService.login()` for better token management.

#### Detailed Explanations
- **Backend Changes**:
  - **`backend/backend/app/core/config.py`**: We added a special URL (called `cognito_jwks_url`) to our settings file. This URL tells our backend where to find the public keys that Cognito (our authentication service) uses to sign the special security tokens (JWTs). Think of JWTs like a signed ID card; this URL helps our backend check if the signature on the ID card is real.
  - **`backend/backend/app/core/security.py`**: This new file is like a security guard for our backend. It has two main jobs:
    1.  **`CognitoJWTVerifier`**: This part fetches the public keys from AWS Cognito. When a user sends a JWT (their ID card), this verifier checks if the token's signature matches one of the public keys. This ensures the token really came from Cognito and hasn't been tampered with. It also checks if the token is for our app (audience) and if it's expired.
    2.  **`get_current_user_from_jwt`**: This is a special function that FastAPI (our backend framework) can use. When someone tries to access a protected part of our app, this function automatically looks for the JWT in their request. It then uses the `CognitoJWTVerifier` to decode and check the token. If the token is valid, it finds the user in our database based on the email (which Cognito calls 'username') and makes the user's information available to the protected part of the app. This is like a bouncer checking your ID card at a club; if it's valid, they let you in and tell the manager who you are.
  - **`backend/backend/app/main.py`**: We updated our main backend file to use this new security guard. We imported the `get_current_user_from_jwt` function and used it to protect a new example endpoint, `/users/me`. Now, if you try to visit `/users/me` without a valid JWT, the backend will reject your request. This ensures that only logged-in users can access their own data.

- **Frontend Changes**:
  - **`ui/src/services/auth.ts`**: This is a new helper file for our frontend (the part of the app you see in your browser). It's like a central place for all login-related actions. It stores both the `access_token` (your short-term access pass) and `refresh_token` (your long-term pass to get new short-term passes) in your browser's local storage. It also has functions to:
    -   Log in a user (`login`).
    -   Log out a user (`logout`).
    -   Get a new `access_token` using the `refresh_token` when the old one expires (`refreshAccessToken`). This is like getting a new daily pass with your season ticket.
    -   Set up an **Axios interceptor** (`initiateAuthInterceptor`). This is the clever part that automatically handles sending and refreshing tokens.
  - **`ui/src/main.tsx`**: We added a line here to start the Axios interceptors from our `authService`. Think of this as telling Axios (our tool for talking to the backend) to always consult our `authService` before sending requests or when it receives an error. It automatically attaches your `access_token` to every request. If the backend says your `access_token` is expired (a 401 error), the interceptor automatically uses your `refresh_token` to get a new `access_token` and retries your original request without you even noticing. If refreshing also fails, it logs you out and sends you back to the login page.
  - **`ui/src/pages/Login.tsx`**: We changed this file so that when you log in, it now uses the `authService.login()` function. This ensures that both your `access_token` and `refresh_token` are properly saved, making the login process more robust and ready for automatic token refreshing.

#### Usage Instructions
- **Backend**: 
  - Ensure your `.env` file has `cognito_user_pool_id`, `cognito_client_id`, and `aws_region` configured correctly.
  - Run the `uvicorn` server as usual.
  - Test the `/users/me` endpoint with a valid access token in the `Authorization: Bearer <token>` header.
- **Frontend**:
  - Ensure your `.env` file for the UI has `VITE_API_BASE_URL` configured.
  - Run `npm run dev` to start the frontend.
  - Log in through the UI.
  - The `access_token` and `refresh_token` will be stored in `localStorage`.
  - Any subsequent authenticated requests will automatically include the `access_token`.
  - If the `access_token` expires, the interceptor will attempt to refresh it automatically.

#### Status/Next Steps
- **Current Status**: Backend and Frontend JWT handling is fully implemented, allowing for secure authenticated requests and automatic token refreshing.
- **Next Batch**: Proceed to define initial IAM roles for basic user permissions (e.g., Anonymous, Member) as per Version 1.1.1 roadmap.

## How did we Test if the Code works:
- [ ] Verified tokens are stored in `localStorage` after login.
- [ ] Verified authenticated requests send `access_token` in `Authorization` header.
- [ ] Verified automatic token refresh upon 401 response and `refresh_token` validity.
- [ ] Verified user is logged out and redirected to login if token refresh fails.
- [ ] Verified `/users/me` a protected backend endpoint returns user data with valid token.
